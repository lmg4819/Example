//
//  Capture51.m
//  Example0
//
//  Created by lmg on 2018/10/25.
//  Copyright © 2018 lmg. All rights reserved.
//

#import "Capture51.h"

@implementation Capture51
/*
 
 + (void)load;
 1.对于加入到运行期系统的类及分类，必定会调用此方法，且仅调用一次。
 2.ios会在应用程序启动的时候调用load方法，在main函数之前调用。
 3.执行分类的load方法之前，会先执行所有超类方法的load方法，顺序为父类->子类->分类
 4.load方法中使用其他类是不安全的
 5.load方法不遵从继承规则
 6.尽可能的精简load方法，因为整个应用程序在执行load方法时会阻塞，即，程序会阻塞直到所有类的
 load方法执行完毕，才会继续
 7.load方法中最常用的就是方法交换
 
 + (void)initialize;
 1.在首次使用该类之前由运行期系统调用，且仅调用一次。
 2.惰性调用，只有当程序使用相关类时，才会调用。
 3.运行期系统会确保initialize方法是在线程安全的环境中执行，即，只有执行initialize的那个线程可以操作类或类实例。其他线程都要先阻塞，等待initialize执行完。
 4.如果类未实现initialize方法，而其超类实现了，那么会运行超类的实现代码，而且会运行两次（load 第5点）
 5.initialize方法也需要尽量精简，一般只应该用来设置内部数据，比如，某个全局状态无法在编译期初始化，可以放在initialize里面。
 
 
 -----------------------------------------------------------------
 //总结
 -----------------------------------------------------------------
 1.在加载阶段，如果类实现了load方法，系统就会调用它，load方法不参与覆写机制。
 2.在首次使用某个类之前，系统会向其发送initialize消息，通常应该在里面判断当前要初始化的类，防止子类未覆写
 initialize情况下调用两次。
 3.load与initialize方法都应该实现得精简一些，有助于保持应用程序的响应能力，也能减少引入“依赖环”（interdependency cycle）的几率
 4.无法在编译器设定的全局变量，可以放在initialize方法里初始化
 */
@end
